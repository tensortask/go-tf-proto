// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: op_def.proto

package framework

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Defines an operation. A NodeDef in a GraphDef specifies an Op by
// using the "op" field which should match the name of a OpDef.
// LINT.IfChange
type OpDef struct {
	// Op names starting with an underscore are reserved for internal use.
	// Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the input(s).
	InputArg []*OpDef_ArgDef `protobuf:"bytes,2,rep,name=input_arg,json=inputArg" json:"input_arg,omitempty"`
	// Description of the output(s).
	OutputArg []*OpDef_ArgDef  `protobuf:"bytes,3,rep,name=output_arg,json=outputArg" json:"output_arg,omitempty"`
	Attr      []*OpDef_AttrDef `protobuf:"bytes,4,rep,name=attr" json:"attr,omitempty"`
	// Optional deprecation based on GraphDef versions.
	Deprecation *OpDeprecation `protobuf:"bytes,8,opt,name=deprecation" json:"deprecation,omitempty"`
	// One-line human-readable description of what the Op does.
	Summary string `protobuf:"bytes,5,opt,name=summary,proto3" json:"summary,omitempty"`
	// Additional, longer human-readable description of what the Op does.
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
	IsCommutative bool `protobuf:"varint,18,opt,name=is_commutative,json=isCommutative,proto3" json:"is_commutative,omitempty"`
	// If is_aggregate is true, then this operation accepts N >= 2
	// inputs and produces 1 output all of the same type.  Should be
	// associative and commutative, and produce output with the same
	// shape as the input.  The optimizer may replace an aggregate op
	// taking input from multiple devices with a tree of aggregate ops
	// that aggregate locally within each device (and possibly within
	// groups of nearby devices) before communicating.
	// TODO(josh11b): Implement that optimization.
	IsAggregate bool `protobuf:"varint,16,opt,name=is_aggregate,json=isAggregate,proto3" json:"is_aggregate,omitempty"`
	// Ops are marked as stateful if their behavior depends on some state beyond
	// their input tensors (e.g. variable reading op) or if they have
	// a side-effect (e.g. printing or asserting ops). Equivalently, stateless ops
	// must always produce the same output for the same input and have
	// no side-effects.
	//
	// By default Ops may be moved between devices.  Stateful ops should
	// either not be moved, or should only be moved if that state can also
	// be moved (e.g. via some sort of save / restore).
	// Stateful ops are guaranteed to never be optimized away by Common
	// Subexpression Elimination (CSE).
	IsStateful bool `protobuf:"varint,17,opt,name=is_stateful,json=isStateful,proto3" json:"is_stateful,omitempty"`
	// By default, all inputs to an Op must be initialized Tensors.  Ops
	// that may initialize tensors for the first time should set this
	// field to true, to allow the Op to take an uninitialized Tensor as
	// input.
	AllowsUninitializedInput bool     `protobuf:"varint,19,opt,name=allows_uninitialized_input,json=allowsUninitializedInput,proto3" json:"allows_uninitialized_input,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *OpDef) Reset()      { *m = OpDef{} }
func (*OpDef) ProtoMessage() {}
func (*OpDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_e92c9b8c489585df, []int{0}
}
func (m *OpDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDef.Merge(dst, src)
}
func (m *OpDef) XXX_Size() int {
	return m.Size()
}
func (m *OpDef) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDef.DiscardUnknown(m)
}

var xxx_messageInfo_OpDef proto.InternalMessageInfo

func (m *OpDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpDef) GetInputArg() []*OpDef_ArgDef {
	if m != nil {
		return m.InputArg
	}
	return nil
}

func (m *OpDef) GetOutputArg() []*OpDef_ArgDef {
	if m != nil {
		return m.OutputArg
	}
	return nil
}

func (m *OpDef) GetAttr() []*OpDef_AttrDef {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *OpDef) GetDeprecation() *OpDeprecation {
	if m != nil {
		return m.Deprecation
	}
	return nil
}

func (m *OpDef) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *OpDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpDef) GetIsCommutative() bool {
	if m != nil {
		return m.IsCommutative
	}
	return false
}

func (m *OpDef) GetIsAggregate() bool {
	if m != nil {
		return m.IsAggregate
	}
	return false
}

func (m *OpDef) GetIsStateful() bool {
	if m != nil {
		return m.IsStateful
	}
	return false
}

func (m *OpDef) GetAllowsUninitializedInput() bool {
	if m != nil {
		return m.AllowsUninitializedInput
	}
	return false
}

// For describing inputs and outputs.
type OpDef_ArgDef struct {
	// Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Human readable description.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Describes the type of one or more tensors that are accepted/produced
	// by this input/output arg.  The only legal combinations are:
	// * For a single tensor: either the "type" field is set or the
	//   "type_attr" field is set to the name of an attr with type "type".
	// * For a sequence of tensors with the same type: the "number_attr"
	//   field will be set to the name of an attr with type "int", and
	//   either the "type" or "type_attr" field will be set as for
	//   single tensors.
	// * For a sequence of tensors, the "type_list_attr" field will be set
	//   to the name of an attr with type "list(type)".
	Type       DataType `protobuf:"varint,3,opt,name=type,proto3,enum=framework.DataType" json:"type,omitempty"`
	TypeAttr   string   `protobuf:"bytes,4,opt,name=type_attr,json=typeAttr,proto3" json:"type_attr,omitempty"`
	NumberAttr string   `protobuf:"bytes,5,opt,name=number_attr,json=numberAttr,proto3" json:"number_attr,omitempty"`
	// If specified, attr must have type "list(type)", and none of
	// type, type_attr, and number_attr may be specified.
	TypeListAttr string `protobuf:"bytes,6,opt,name=type_list_attr,json=typeListAttr,proto3" json:"type_list_attr,omitempty"`
	// For inputs: if true, the inputs are required to be refs.
	//   By default, inputs can be either refs or non-refs.
	// For outputs: if true, outputs are refs, otherwise they are not.
	IsRef                bool     `protobuf:"varint,16,opt,name=is_ref,json=isRef,proto3" json:"is_ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpDef_ArgDef) Reset()      { *m = OpDef_ArgDef{} }
func (*OpDef_ArgDef) ProtoMessage() {}
func (*OpDef_ArgDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_e92c9b8c489585df, []int{0, 0}
}
func (m *OpDef_ArgDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDef_ArgDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDef_ArgDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDef_ArgDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDef_ArgDef.Merge(dst, src)
}
func (m *OpDef_ArgDef) XXX_Size() int {
	return m.Size()
}
func (m *OpDef_ArgDef) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDef_ArgDef.DiscardUnknown(m)
}

var xxx_messageInfo_OpDef_ArgDef proto.InternalMessageInfo

func (m *OpDef_ArgDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpDef_ArgDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpDef_ArgDef) GetType() DataType {
	if m != nil {
		return m.Type
	}
	return DataType_DT_INVALID
}

func (m *OpDef_ArgDef) GetTypeAttr() string {
	if m != nil {
		return m.TypeAttr
	}
	return ""
}

func (m *OpDef_ArgDef) GetNumberAttr() string {
	if m != nil {
		return m.NumberAttr
	}
	return ""
}

func (m *OpDef_ArgDef) GetTypeListAttr() string {
	if m != nil {
		return m.TypeListAttr
	}
	return ""
}

func (m *OpDef_ArgDef) GetIsRef() bool {
	if m != nil {
		return m.IsRef
	}
	return false
}

// Description of the graph-construction-time configuration of this
// Op.  That is to say, this describes the attr fields that will
// be specified in the NodeDef.
type OpDef_AttrDef struct {
	// A descriptive name for the argument.  May be used, e.g. by the
	// Python client, as a keyword argument name, and so should match
	// the regexp "[a-z][a-z0-9_]+".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// One of the type names from attr_value.proto ("string", "list(string)",
	// "int", etc.).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// A reasonable default for this attribute if the user does not supply
	// a value.  If not specified, the user must supply a value.
	DefaultValue *AttrValue `protobuf:"bytes,3,opt,name=default_value,json=defaultValue" json:"default_value,omitempty"`
	// Human-readable description.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// For type == "int", this is a minimum value.  For "list(___)"
	// types, this is the minimum length.
	HasMinimum bool  `protobuf:"varint,5,opt,name=has_minimum,json=hasMinimum,proto3" json:"has_minimum,omitempty"`
	Minimum    int64 `protobuf:"varint,6,opt,name=minimum,proto3" json:"minimum,omitempty"`
	// The set of allowed values.  Has type that is the "list" version
	// of the "type" field above (uses the "list" field of AttrValue).
	// If type == "type" or "list(type)" above, then the "type" field
	// of "allowed_values.list" has the set of allowed DataTypes.
	// If type == "string" or "list(string)", then the "s" field of
	// "allowed_values.list" has the set of allowed strings.
	AllowedValues        *AttrValue `protobuf:"bytes,7,opt,name=allowed_values,json=allowedValues" json:"allowed_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *OpDef_AttrDef) Reset()      { *m = OpDef_AttrDef{} }
func (*OpDef_AttrDef) ProtoMessage() {}
func (*OpDef_AttrDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_e92c9b8c489585df, []int{0, 1}
}
func (m *OpDef_AttrDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDef_AttrDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDef_AttrDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDef_AttrDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDef_AttrDef.Merge(dst, src)
}
func (m *OpDef_AttrDef) XXX_Size() int {
	return m.Size()
}
func (m *OpDef_AttrDef) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDef_AttrDef.DiscardUnknown(m)
}

var xxx_messageInfo_OpDef_AttrDef proto.InternalMessageInfo

func (m *OpDef_AttrDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpDef_AttrDef) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *OpDef_AttrDef) GetDefaultValue() *AttrValue {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *OpDef_AttrDef) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpDef_AttrDef) GetHasMinimum() bool {
	if m != nil {
		return m.HasMinimum
	}
	return false
}

func (m *OpDef_AttrDef) GetMinimum() int64 {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *OpDef_AttrDef) GetAllowedValues() *AttrValue {
	if m != nil {
		return m.AllowedValues
	}
	return nil
}

// Information about version-dependent deprecation of an op
type OpDeprecation struct {
	// First GraphDef version at which the op is disallowed.
	Version int32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Explanation of why it was deprecated and what to use instead.
	Explanation          string   `protobuf:"bytes,2,opt,name=explanation,proto3" json:"explanation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpDeprecation) Reset()      { *m = OpDeprecation{} }
func (*OpDeprecation) ProtoMessage() {}
func (*OpDeprecation) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_e92c9b8c489585df, []int{1}
}
func (m *OpDeprecation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpDeprecation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpDeprecation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpDeprecation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpDeprecation.Merge(dst, src)
}
func (m *OpDeprecation) XXX_Size() int {
	return m.Size()
}
func (m *OpDeprecation) XXX_DiscardUnknown() {
	xxx_messageInfo_OpDeprecation.DiscardUnknown(m)
}

var xxx_messageInfo_OpDeprecation proto.InternalMessageInfo

func (m *OpDeprecation) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *OpDeprecation) GetExplanation() string {
	if m != nil {
		return m.Explanation
	}
	return ""
}

// A collection of OpDefs
type OpList struct {
	Op                   []*OpDef `protobuf:"bytes,1,rep,name=op" json:"op,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpList) Reset()      { *m = OpList{} }
func (*OpList) ProtoMessage() {}
func (*OpList) Descriptor() ([]byte, []int) {
	return fileDescriptor_op_def_e92c9b8c489585df, []int{2}
}
func (m *OpList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpList.Merge(dst, src)
}
func (m *OpList) XXX_Size() int {
	return m.Size()
}
func (m *OpList) XXX_DiscardUnknown() {
	xxx_messageInfo_OpList.DiscardUnknown(m)
}

var xxx_messageInfo_OpList proto.InternalMessageInfo

func (m *OpList) GetOp() []*OpDef {
	if m != nil {
		return m.Op
	}
	return nil
}

func init() {
	proto.RegisterType((*OpDef)(nil), "framework.OpDef")
	proto.RegisterType((*OpDef_ArgDef)(nil), "framework.OpDef.ArgDef")
	proto.RegisterType((*OpDef_AttrDef)(nil), "framework.OpDef.AttrDef")
	proto.RegisterType((*OpDeprecation)(nil), "framework.OpDeprecation")
	proto.RegisterType((*OpList)(nil), "framework.OpList")
}
func (this *OpDef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OpDef)
	if !ok {
		that2, ok := that.(OpDef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OpDef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OpDef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OpDef but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if len(this.InputArg) != len(that1.InputArg) {
		return fmt.Errorf("InputArg this(%v) Not Equal that(%v)", len(this.InputArg), len(that1.InputArg))
	}
	for i := range this.InputArg {
		if !this.InputArg[i].Equal(that1.InputArg[i]) {
			return fmt.Errorf("InputArg this[%v](%v) Not Equal that[%v](%v)", i, this.InputArg[i], i, that1.InputArg[i])
		}
	}
	if len(this.OutputArg) != len(that1.OutputArg) {
		return fmt.Errorf("OutputArg this(%v) Not Equal that(%v)", len(this.OutputArg), len(that1.OutputArg))
	}
	for i := range this.OutputArg {
		if !this.OutputArg[i].Equal(that1.OutputArg[i]) {
			return fmt.Errorf("OutputArg this[%v](%v) Not Equal that[%v](%v)", i, this.OutputArg[i], i, that1.OutputArg[i])
		}
	}
	if len(this.Attr) != len(that1.Attr) {
		return fmt.Errorf("Attr this(%v) Not Equal that(%v)", len(this.Attr), len(that1.Attr))
	}
	for i := range this.Attr {
		if !this.Attr[i].Equal(that1.Attr[i]) {
			return fmt.Errorf("Attr this[%v](%v) Not Equal that[%v](%v)", i, this.Attr[i], i, that1.Attr[i])
		}
	}
	if !this.Deprecation.Equal(that1.Deprecation) {
		return fmt.Errorf("Deprecation this(%v) Not Equal that(%v)", this.Deprecation, that1.Deprecation)
	}
	if this.Summary != that1.Summary {
		return fmt.Errorf("Summary this(%v) Not Equal that(%v)", this.Summary, that1.Summary)
	}
	if this.Description != that1.Description {
		return fmt.Errorf("Description this(%v) Not Equal that(%v)", this.Description, that1.Description)
	}
	if this.IsCommutative != that1.IsCommutative {
		return fmt.Errorf("IsCommutative this(%v) Not Equal that(%v)", this.IsCommutative, that1.IsCommutative)
	}
	if this.IsAggregate != that1.IsAggregate {
		return fmt.Errorf("IsAggregate this(%v) Not Equal that(%v)", this.IsAggregate, that1.IsAggregate)
	}
	if this.IsStateful != that1.IsStateful {
		return fmt.Errorf("IsStateful this(%v) Not Equal that(%v)", this.IsStateful, that1.IsStateful)
	}
	if this.AllowsUninitializedInput != that1.AllowsUninitializedInput {
		return fmt.Errorf("AllowsUninitializedInput this(%v) Not Equal that(%v)", this.AllowsUninitializedInput, that1.AllowsUninitializedInput)
	}
	return nil
}
func (this *OpDef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpDef)
	if !ok {
		that2, ok := that.(OpDef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.InputArg) != len(that1.InputArg) {
		return false
	}
	for i := range this.InputArg {
		if !this.InputArg[i].Equal(that1.InputArg[i]) {
			return false
		}
	}
	if len(this.OutputArg) != len(that1.OutputArg) {
		return false
	}
	for i := range this.OutputArg {
		if !this.OutputArg[i].Equal(that1.OutputArg[i]) {
			return false
		}
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if !this.Attr[i].Equal(that1.Attr[i]) {
			return false
		}
	}
	if !this.Deprecation.Equal(that1.Deprecation) {
		return false
	}
	if this.Summary != that1.Summary {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.IsCommutative != that1.IsCommutative {
		return false
	}
	if this.IsAggregate != that1.IsAggregate {
		return false
	}
	if this.IsStateful != that1.IsStateful {
		return false
	}
	if this.AllowsUninitializedInput != that1.AllowsUninitializedInput {
		return false
	}
	return true
}
func (this *OpDef_ArgDef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OpDef_ArgDef)
	if !ok {
		that2, ok := that.(OpDef_ArgDef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OpDef_ArgDef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OpDef_ArgDef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OpDef_ArgDef but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Description != that1.Description {
		return fmt.Errorf("Description this(%v) Not Equal that(%v)", this.Description, that1.Description)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.TypeAttr != that1.TypeAttr {
		return fmt.Errorf("TypeAttr this(%v) Not Equal that(%v)", this.TypeAttr, that1.TypeAttr)
	}
	if this.NumberAttr != that1.NumberAttr {
		return fmt.Errorf("NumberAttr this(%v) Not Equal that(%v)", this.NumberAttr, that1.NumberAttr)
	}
	if this.TypeListAttr != that1.TypeListAttr {
		return fmt.Errorf("TypeListAttr this(%v) Not Equal that(%v)", this.TypeListAttr, that1.TypeListAttr)
	}
	if this.IsRef != that1.IsRef {
		return fmt.Errorf("IsRef this(%v) Not Equal that(%v)", this.IsRef, that1.IsRef)
	}
	return nil
}
func (this *OpDef_ArgDef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpDef_ArgDef)
	if !ok {
		that2, ok := that.(OpDef_ArgDef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.TypeAttr != that1.TypeAttr {
		return false
	}
	if this.NumberAttr != that1.NumberAttr {
		return false
	}
	if this.TypeListAttr != that1.TypeListAttr {
		return false
	}
	if this.IsRef != that1.IsRef {
		return false
	}
	return true
}
func (this *OpDef_AttrDef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OpDef_AttrDef)
	if !ok {
		that2, ok := that.(OpDef_AttrDef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OpDef_AttrDef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OpDef_AttrDef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OpDef_AttrDef but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.DefaultValue.Equal(that1.DefaultValue) {
		return fmt.Errorf("DefaultValue this(%v) Not Equal that(%v)", this.DefaultValue, that1.DefaultValue)
	}
	if this.Description != that1.Description {
		return fmt.Errorf("Description this(%v) Not Equal that(%v)", this.Description, that1.Description)
	}
	if this.HasMinimum != that1.HasMinimum {
		return fmt.Errorf("HasMinimum this(%v) Not Equal that(%v)", this.HasMinimum, that1.HasMinimum)
	}
	if this.Minimum != that1.Minimum {
		return fmt.Errorf("Minimum this(%v) Not Equal that(%v)", this.Minimum, that1.Minimum)
	}
	if !this.AllowedValues.Equal(that1.AllowedValues) {
		return fmt.Errorf("AllowedValues this(%v) Not Equal that(%v)", this.AllowedValues, that1.AllowedValues)
	}
	return nil
}
func (this *OpDef_AttrDef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpDef_AttrDef)
	if !ok {
		that2, ok := that.(OpDef_AttrDef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.DefaultValue.Equal(that1.DefaultValue) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.HasMinimum != that1.HasMinimum {
		return false
	}
	if this.Minimum != that1.Minimum {
		return false
	}
	if !this.AllowedValues.Equal(that1.AllowedValues) {
		return false
	}
	return true
}
func (this *OpDeprecation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OpDeprecation)
	if !ok {
		that2, ok := that.(OpDeprecation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OpDeprecation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OpDeprecation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OpDeprecation but is not nil && this == nil")
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.Explanation != that1.Explanation {
		return fmt.Errorf("Explanation this(%v) Not Equal that(%v)", this.Explanation, that1.Explanation)
	}
	return nil
}
func (this *OpDeprecation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpDeprecation)
	if !ok {
		that2, ok := that.(OpDeprecation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Explanation != that1.Explanation {
		return false
	}
	return true
}
func (this *OpList) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OpList)
	if !ok {
		that2, ok := that.(OpList)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OpList")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OpList but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OpList but is not nil && this == nil")
	}
	if len(this.Op) != len(that1.Op) {
		return fmt.Errorf("Op this(%v) Not Equal that(%v)", len(this.Op), len(that1.Op))
	}
	for i := range this.Op {
		if !this.Op[i].Equal(that1.Op[i]) {
			return fmt.Errorf("Op this[%v](%v) Not Equal that[%v](%v)", i, this.Op[i], i, that1.Op[i])
		}
	}
	return nil
}
func (this *OpList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OpList)
	if !ok {
		that2, ok := that.(OpList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Op) != len(that1.Op) {
		return false
	}
	for i := range this.Op {
		if !this.Op[i].Equal(that1.Op[i]) {
			return false
		}
	}
	return true
}
func (this *OpDef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&framework.OpDef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.InputArg != nil {
		s = append(s, "InputArg: "+fmt.Sprintf("%#v", this.InputArg)+",\n")
	}
	if this.OutputArg != nil {
		s = append(s, "OutputArg: "+fmt.Sprintf("%#v", this.OutputArg)+",\n")
	}
	if this.Attr != nil {
		s = append(s, "Attr: "+fmt.Sprintf("%#v", this.Attr)+",\n")
	}
	if this.Deprecation != nil {
		s = append(s, "Deprecation: "+fmt.Sprintf("%#v", this.Deprecation)+",\n")
	}
	s = append(s, "Summary: "+fmt.Sprintf("%#v", this.Summary)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "IsCommutative: "+fmt.Sprintf("%#v", this.IsCommutative)+",\n")
	s = append(s, "IsAggregate: "+fmt.Sprintf("%#v", this.IsAggregate)+",\n")
	s = append(s, "IsStateful: "+fmt.Sprintf("%#v", this.IsStateful)+",\n")
	s = append(s, "AllowsUninitializedInput: "+fmt.Sprintf("%#v", this.AllowsUninitializedInput)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpDef_ArgDef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&framework.OpDef_ArgDef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "TypeAttr: "+fmt.Sprintf("%#v", this.TypeAttr)+",\n")
	s = append(s, "NumberAttr: "+fmt.Sprintf("%#v", this.NumberAttr)+",\n")
	s = append(s, "TypeListAttr: "+fmt.Sprintf("%#v", this.TypeListAttr)+",\n")
	s = append(s, "IsRef: "+fmt.Sprintf("%#v", this.IsRef)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpDef_AttrDef) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&framework.OpDef_AttrDef{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.DefaultValue != nil {
		s = append(s, "DefaultValue: "+fmt.Sprintf("%#v", this.DefaultValue)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "HasMinimum: "+fmt.Sprintf("%#v", this.HasMinimum)+",\n")
	s = append(s, "Minimum: "+fmt.Sprintf("%#v", this.Minimum)+",\n")
	if this.AllowedValues != nil {
		s = append(s, "AllowedValues: "+fmt.Sprintf("%#v", this.AllowedValues)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpDeprecation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&framework.OpDeprecation{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Explanation: "+fmt.Sprintf("%#v", this.Explanation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&framework.OpList{")
	if this.Op != nil {
		s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringOpDef(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *OpDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.InputArg) > 0 {
		for _, msg := range m.InputArg {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputArg) > 0 {
		for _, msg := range m.OutputArg {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attr) > 0 {
		for _, msg := range m.Attr {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Deprecation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Deprecation.Size()))
		n1, err := m.Deprecation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IsAggregate {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IsAggregate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsStateful {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsStateful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsCommutative {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.IsCommutative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowsUninitializedInput {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.AllowsUninitializedInput {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *OpDef_ArgDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDef_ArgDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Type))
	}
	if len(m.TypeAttr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.TypeAttr)))
		i += copy(dAtA[i:], m.TypeAttr)
	}
	if len(m.NumberAttr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.NumberAttr)))
		i += copy(dAtA[i:], m.NumberAttr)
	}
	if len(m.TypeListAttr) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.TypeListAttr)))
		i += copy(dAtA[i:], m.TypeListAttr)
	}
	if m.IsRef {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IsRef {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *OpDef_AttrDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDef_AttrDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.DefaultValue != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.DefaultValue.Size()))
		n2, err := m.DefaultValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.HasMinimum {
		dAtA[i] = 0x28
		i++
		if m.HasMinimum {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Minimum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Minimum))
	}
	if m.AllowedValues != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.AllowedValues.Size()))
		n3, err := m.AllowedValues.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *OpDeprecation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpDeprecation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(m.Version))
	}
	if len(m.Explanation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpDef(dAtA, i, uint64(len(m.Explanation)))
		i += copy(dAtA[i:], m.Explanation)
	}
	return i, nil
}

func (m *OpList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Op) > 0 {
		for _, msg := range m.Op {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpDef(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintOpDef(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedOpDef(r randyOpDef, easy bool) *OpDef {
	this := &OpDef{}
	this.Name = string(randStringOpDef(r))
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.InputArg = make([]*OpDef_ArgDef, v1)
		for i := 0; i < v1; i++ {
			this.InputArg[i] = NewPopulatedOpDef_ArgDef(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.OutputArg = make([]*OpDef_ArgDef, v2)
		for i := 0; i < v2; i++ {
			this.OutputArg[i] = NewPopulatedOpDef_ArgDef(r, easy)
		}
	}
	if r.Intn(10) == 0 {
		v3 := r.Intn(5)
		this.Attr = make([]*OpDef_AttrDef, v3)
		for i := 0; i < v3; i++ {
			this.Attr[i] = NewPopulatedOpDef_AttrDef(r, easy)
		}
	}
	this.Summary = string(randStringOpDef(r))
	this.Description = string(randStringOpDef(r))
	if r.Intn(10) != 0 {
		this.Deprecation = NewPopulatedOpDeprecation(r, easy)
	}
	this.IsAggregate = bool(bool(r.Intn(2) == 0))
	this.IsStateful = bool(bool(r.Intn(2) == 0))
	this.IsCommutative = bool(bool(r.Intn(2) == 0))
	this.AllowsUninitializedInput = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOpDef_ArgDef(r randyOpDef, easy bool) *OpDef_ArgDef {
	this := &OpDef_ArgDef{}
	this.Name = string(randStringOpDef(r))
	this.Description = string(randStringOpDef(r))
	this.Type = DataType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123}[r.Intn(47)])
	this.TypeAttr = string(randStringOpDef(r))
	this.NumberAttr = string(randStringOpDef(r))
	this.TypeListAttr = string(randStringOpDef(r))
	this.IsRef = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOpDef_AttrDef(r randyOpDef, easy bool) *OpDef_AttrDef {
	this := &OpDef_AttrDef{}
	this.Name = string(randStringOpDef(r))
	this.Type = string(randStringOpDef(r))
	if r.Intn(10) == 0 {
		this.DefaultValue = NewPopulatedAttrValue(r, easy)
	}
	this.Description = string(randStringOpDef(r))
	this.HasMinimum = bool(bool(r.Intn(2) == 0))
	this.Minimum = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Minimum *= -1
	}
	if r.Intn(10) == 0 {
		this.AllowedValues = NewPopulatedAttrValue(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOpDeprecation(r randyOpDef, easy bool) *OpDeprecation {
	this := &OpDeprecation{}
	this.Version = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	this.Explanation = string(randStringOpDef(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOpList(r randyOpDef, easy bool) *OpList {
	this := &OpList{}
	if r.Intn(10) == 0 {
		v4 := r.Intn(5)
		this.Op = make([]*OpDef, v4)
		for i := 0; i < v4; i++ {
			this.Op[i] = NewPopulatedOpDef(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyOpDef interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOpDef(r randyOpDef) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOpDef(r randyOpDef) string {
	v5 := r.Intn(100)
	tmps := make([]rune, v5)
	for i := 0; i < v5; i++ {
		tmps[i] = randUTF8RuneOpDef(r)
	}
	return string(tmps)
}
func randUnrecognizedOpDef(r randyOpDef, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldOpDef(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldOpDef(dAtA []byte, r randyOpDef, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateOpDef(dAtA, uint64(key))
		v6 := r.Int63()
		if r.Intn(2) == 0 {
			v6 *= -1
		}
		dAtA = encodeVarintPopulateOpDef(dAtA, uint64(v6))
	case 1:
		dAtA = encodeVarintPopulateOpDef(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateOpDef(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateOpDef(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateOpDef(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateOpDef(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *OpDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if len(m.InputArg) > 0 {
		for _, e := range m.InputArg {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	if len(m.OutputArg) > 0 {
		for _, e := range m.OutputArg {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	if len(m.Attr) > 0 {
		for _, e := range m.Attr {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.Deprecation != nil {
		l = m.Deprecation.Size()
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.IsAggregate {
		n += 3
	}
	if m.IsStateful {
		n += 3
	}
	if m.IsCommutative {
		n += 3
	}
	if m.AllowsUninitializedInput {
		n += 3
	}
	return n
}

func (m *OpDef_ArgDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOpDef(uint64(m.Type))
	}
	l = len(m.TypeAttr)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.NumberAttr)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.TypeListAttr)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.IsRef {
		n += 3
	}
	return n
}

func (m *OpDef_AttrDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovOpDef(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	if m.HasMinimum {
		n += 2
	}
	if m.Minimum != 0 {
		n += 1 + sovOpDef(uint64(m.Minimum))
	}
	if m.AllowedValues != nil {
		l = m.AllowedValues.Size()
		n += 1 + l + sovOpDef(uint64(l))
	}
	return n
}

func (m *OpDeprecation) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovOpDef(uint64(m.Version))
	}
	l = len(m.Explanation)
	if l > 0 {
		n += 1 + l + sovOpDef(uint64(l))
	}
	return n
}

func (m *OpList) Size() (n int) {
	var l int
	_ = l
	if len(m.Op) > 0 {
		for _, e := range m.Op {
			l = e.Size()
			n += 1 + l + sovOpDef(uint64(l))
		}
	}
	return n
}

func sovOpDef(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOpDef(x uint64) (n int) {
	return sovOpDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *OpDef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpDef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`InputArg:` + strings.Replace(fmt.Sprintf("%v", this.InputArg), "OpDef_ArgDef", "OpDef_ArgDef", 1) + `,`,
		`OutputArg:` + strings.Replace(fmt.Sprintf("%v", this.OutputArg), "OpDef_ArgDef", "OpDef_ArgDef", 1) + `,`,
		`Attr:` + strings.Replace(fmt.Sprintf("%v", this.Attr), "OpDef_AttrDef", "OpDef_AttrDef", 1) + `,`,
		`Summary:` + fmt.Sprintf("%v", this.Summary) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Deprecation:` + strings.Replace(fmt.Sprintf("%v", this.Deprecation), "OpDeprecation", "OpDeprecation", 1) + `,`,
		`IsAggregate:` + fmt.Sprintf("%v", this.IsAggregate) + `,`,
		`IsStateful:` + fmt.Sprintf("%v", this.IsStateful) + `,`,
		`IsCommutative:` + fmt.Sprintf("%v", this.IsCommutative) + `,`,
		`AllowsUninitializedInput:` + fmt.Sprintf("%v", this.AllowsUninitializedInput) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpDef_ArgDef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpDef_ArgDef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`TypeAttr:` + fmt.Sprintf("%v", this.TypeAttr) + `,`,
		`NumberAttr:` + fmt.Sprintf("%v", this.NumberAttr) + `,`,
		`TypeListAttr:` + fmt.Sprintf("%v", this.TypeListAttr) + `,`,
		`IsRef:` + fmt.Sprintf("%v", this.IsRef) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpDef_AttrDef) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpDef_AttrDef{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DefaultValue:` + strings.Replace(fmt.Sprintf("%v", this.DefaultValue), "AttrValue", "AttrValue", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`HasMinimum:` + fmt.Sprintf("%v", this.HasMinimum) + `,`,
		`Minimum:` + fmt.Sprintf("%v", this.Minimum) + `,`,
		`AllowedValues:` + strings.Replace(fmt.Sprintf("%v", this.AllowedValues), "AttrValue", "AttrValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpDeprecation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpDeprecation{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Explanation:` + fmt.Sprintf("%v", this.Explanation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpList{`,
		`Op:` + strings.Replace(fmt.Sprintf("%v", this.Op), "OpDef", "OpDef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOpDef(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *OpDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputArg = append(m.InputArg, &OpDef_ArgDef{})
			if err := m.InputArg[len(m.InputArg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputArg = append(m.OutputArg, &OpDef_ArgDef{})
			if err := m.OutputArg[len(m.OutputArg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attr = append(m.Attr, &OpDef_AttrDef{})
			if err := m.Attr[len(m.Attr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deprecation == nil {
				m.Deprecation = &OpDeprecation{}
			}
			if err := m.Deprecation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAggregate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAggregate = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStateful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStateful = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCommutative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCommutative = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowsUninitializedInput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowsUninitializedInput = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpDef_ArgDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumberAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeListAttr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeListAttr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRef", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRef = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpDef_AttrDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &AttrValue{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMinimum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMinimum = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			m.Minimum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minimum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedValues == nil {
				m.AllowedValues = &AttrValue{}
			}
			if err := m.AllowedValues.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpDeprecation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpDeprecation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpDeprecation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Explanation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Explanation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpDef
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = append(m.Op, &OpDef{})
			if err := m.Op[len(m.Op)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOpDef
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOpDef
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOpDef(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOpDef = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpDef   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("op_def.proto", fileDescriptor_op_def_e92c9b8c489585df) }

var fileDescriptor_op_def_e92c9b8c489585df = []byte{
	// 683 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x6e, 0x13, 0x3b,
	0x14, 0xae, 0xf3, 0x9f, 0x33, 0x49, 0xd4, 0xeb, 0xde, 0xab, 0x6b, 0x05, 0x69, 0x1a, 0x22, 0x10,
	0x11, 0x42, 0xa9, 0x54, 0x10, 0x12, 0x3f, 0x9b, 0x96, 0x6e, 0x10, 0xa0, 0x56, 0xc3, 0x8f, 0xd8,
	0x8d, 0xdc, 0xc6, 0x33, 0xb5, 0x98, 0x19, 0x8f, 0x6c, 0x4f, 0x4b, 0x59, 0xb1, 0x62, 0xcd, 0x63,
	0xf0, 0x08, 0x3c, 0x01, 0x62, 0xc9, 0x92, 0x65, 0x13, 0x5e, 0x80, 0x65, 0x97, 0xc8, 0xf6, 0xa4,
	0x0d, 0x6d, 0xd5, 0xd5, 0xcc, 0xf9, 0xce, 0xf7, 0xd9, 0xe7, 0x7c, 0xc7, 0x36, 0x74, 0x44, 0x1e,
	0x4e, 0x58, 0x34, 0xce, 0xa5, 0xd0, 0x02, 0xb7, 0x23, 0x49, 0x53, 0x76, 0x28, 0xe4, 0xbb, 0xfe,
	0x30, 0x16, 0xb1, 0x58, 0xb3, 0xf0, 0x6e, 0x11, 0xad, 0x99, 0xc8, 0x06, 0xf6, 0xcf, 0xd1, 0xfb,
	0xcb, 0x54, 0x6b, 0x19, 0x1e, 0xd0, 0xa4, 0x60, 0x25, 0xe2, 0xe9, 0xa3, 0x9c, 0x29, 0x17, 0x0c,
	0xbf, 0x35, 0xa1, 0xbe, 0x9d, 0x6f, 0xb1, 0x08, 0x63, 0xa8, 0x65, 0x34, 0x65, 0x04, 0x0d, 0xd0,
	0xa8, 0x1d, 0xd8, 0x7f, 0x7c, 0x0f, 0xda, 0x3c, 0xcb, 0x0b, 0x1d, 0x52, 0x19, 0x93, 0xca, 0xa0,
	0x3a, 0xf2, 0xd6, 0xff, 0x1f, 0x9f, 0xee, 0x3f, 0xb6, 0xc2, 0xf1, 0x86, 0x8c, 0xb7, 0x58, 0x14,
	0xb4, 0x2c, 0x73, 0x43, 0xc6, 0xf8, 0x3e, 0x80, 0x28, 0xf4, 0x5c, 0x56, 0xbd, 0x5a, 0xd6, 0x76,
	0x54, 0xa3, 0xbb, 0x03, 0x35, 0x53, 0x2c, 0xa9, 0x59, 0x05, 0xb9, 0xa8, 0xd0, 0x5a, 0x1a, 0x89,
	0x65, 0x61, 0x02, 0x4d, 0x55, 0xa4, 0x29, 0x95, 0x47, 0xa4, 0x6e, 0x4b, 0x9e, 0x87, 0x78, 0x00,
	0xde, 0x84, 0xa9, 0x3d, 0xc9, 0x73, 0xcd, 0x45, 0x46, 0x1a, 0x36, 0xbb, 0x08, 0xe1, 0x87, 0x86,
	0x91, 0x4b, 0xb6, 0x47, 0x2d, 0xa3, 0x35, 0x40, 0x97, 0x6c, 0x78, 0x9a, 0x0f, 0x16, 0xc9, 0xf8,
	0x3a, 0x74, 0xb8, 0x0a, 0x69, 0x1c, 0x4b, 0x16, 0x53, 0xcd, 0xc8, 0xf2, 0x00, 0x8d, 0x5a, 0x81,
	0xc7, 0xd5, 0xc6, 0x1c, 0xc2, 0xab, 0xe0, 0x71, 0x15, 0x2a, 0x4d, 0x35, 0x8b, 0x8a, 0x84, 0xfc,
	0x63, 0x19, 0xc0, 0xd5, 0xcb, 0x12, 0xc1, 0x37, 0xa1, 0xc7, 0x55, 0xb8, 0x27, 0xd2, 0xb4, 0xd0,
	0x54, 0xf3, 0x03, 0x46, 0xb0, 0xe5, 0x74, 0xb9, 0x7a, 0x72, 0x06, 0xe2, 0xc7, 0xd0, 0xa7, 0x49,
	0x22, 0x0e, 0x55, 0x58, 0x64, 0x3c, 0xe3, 0x9a, 0xd3, 0x84, 0x7f, 0x60, 0x93, 0xd0, 0x3a, 0x4d,
	0x56, 0xac, 0x84, 0x38, 0xc6, 0xeb, 0x45, 0xc2, 0x53, 0x93, 0xef, 0xcf, 0x10, 0x34, 0x9c, 0xc9,
	0x97, 0xce, 0xf6, 0x9c, 0x4b, 0x95, 0x8b, 0x2e, 0xdd, 0x82, 0x9a, 0x39, 0x2a, 0xa4, 0x3a, 0x40,
	0xa3, 0xde, 0xfa, 0xca, 0x82, 0x3d, 0x5b, 0x54, 0xd3, 0x57, 0x47, 0x39, 0x0b, 0x2c, 0x01, 0x5f,
	0x83, 0xb6, 0xf9, 0x86, 0xe5, 0xf4, 0xcc, 0x42, 0x2d, 0x03, 0x98, 0x81, 0x19, 0x33, 0xb2, 0x22,
	0xdd, 0x65, 0xd2, 0xa5, 0xdd, 0xac, 0xc0, 0x41, 0x96, 0x70, 0x03, 0x7a, 0x56, 0x9d, 0x70, 0xa5,
	0x1d, 0xc7, 0x4d, 0xac, 0x63, 0xd0, 0xe7, 0x5c, 0x69, 0xcb, 0xfa, 0x0f, 0x1a, 0x5c, 0x85, 0x92,
	0x45, 0xa5, 0xe1, 0x75, 0xae, 0x02, 0x16, 0xf5, 0x3f, 0x55, 0xa0, 0x59, 0x9e, 0x8b, 0x4b, 0xbb,
	0xc4, 0x65, 0x0f, 0xae, 0x3d, 0x57, 0xee, 0x03, 0xe8, 0x4e, 0x58, 0x44, 0x8b, 0x44, 0xbb, 0x7b,
	0x61, 0x1b, 0xf4, 0xd6, 0xff, 0x5d, 0x68, 0xd0, 0x2c, 0xf9, 0xc6, 0xe4, 0x82, 0x4e, 0x49, 0xb5,
	0xd1, 0x79, 0xd3, 0x6a, 0x17, 0x4d, 0x5b, 0x05, 0x6f, 0x9f, 0xaa, 0x30, 0xe5, 0x19, 0x4f, 0x8b,
	0xd4, 0xb6, 0xdb, 0x0a, 0x60, 0x9f, 0xaa, 0x17, 0x0e, 0x31, 0xe7, 0x76, 0x9e, 0x34, 0x7d, 0x56,
	0x83, 0x79, 0x88, 0x1f, 0x41, 0xcf, 0x0e, 0x93, 0x4d, 0x5c, 0x5d, 0x8a, 0x34, 0xaf, 0x28, 0xac,
	0x5b, 0x72, 0x6d, 0xa4, 0x86, 0xcf, 0xa0, 0xfb, 0xd7, 0xa1, 0x35, 0xfb, 0x1c, 0x30, 0xa9, 0x4c,
	0x99, 0xc6, 0x90, 0x7a, 0x30, 0x0f, 0x4d, 0x13, 0xec, 0x7d, 0x9e, 0xd0, 0x8c, 0x2e, 0x4e, 0x7e,
	0x01, 0x1a, 0xde, 0x86, 0xc6, 0x76, 0x6e, 0xac, 0xc7, 0x03, 0xa8, 0x88, 0x9c, 0x20, 0x7b, 0x23,
	0x97, 0xcf, 0xdf, 0xc8, 0xa0, 0x22, 0xf2, 0xcd, 0xb7, 0x3f, 0xa7, 0xfe, 0xd2, 0xf1, 0xd4, 0x47,
	0xbf, 0xa7, 0x3e, 0x3a, 0x99, 0xfa, 0xe8, 0xe3, 0xcc, 0x47, 0x5f, 0x66, 0x3e, 0xfa, 0x3a, 0xf3,
	0xd1, 0xf7, 0x99, 0x8f, 0x7e, 0xcc, 0x7c, 0x74, 0x3c, 0xf3, 0xd1, 0xe7, 0x5f, 0xfe, 0x12, 0x10,
	0x21, 0xe3, 0xb1, 0x66, 0x99, 0x12, 0x32, 0x4a, 0xc4, 0xe1, 0xd9, 0x8a, 0x9b, 0x9e, 0x5d, 0x72,
	0xc7, 0xbc, 0x4a, 0x6a, 0x07, 0x9d, 0x20, 0xb4, 0xdb, 0xb0, 0x4f, 0xd4, 0xdd, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xd3, 0xe3, 0x07, 0xe9, 0x00, 0x05, 0x00, 0x00,
}
